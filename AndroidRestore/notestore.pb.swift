// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: notestore.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///Represents a color
struct ProtoColor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var red: Float {
    get {return _red ?? 0}
    set {_red = newValue}
  }
  /// Returns true if `red` has been explicitly set.
  var hasRed: Bool {return self._red != nil}
  /// Clears the value of `red`. Subsequent reads from it will return its default value.
  mutating func clearRed() {self._red = nil}

  var green: Float {
    get {return _green ?? 0}
    set {_green = newValue}
  }
  /// Returns true if `green` has been explicitly set.
  var hasGreen: Bool {return self._green != nil}
  /// Clears the value of `green`. Subsequent reads from it will return its default value.
  mutating func clearGreen() {self._green = nil}

  var blue: Float {
    get {return _blue ?? 0}
    set {_blue = newValue}
  }
  /// Returns true if `blue` has been explicitly set.
  var hasBlue: Bool {return self._blue != nil}
  /// Clears the value of `blue`. Subsequent reads from it will return its default value.
  mutating func clearBlue() {self._blue = nil}

  var alpha: Float {
    get {return _alpha ?? 0}
    set {_alpha = newValue}
  }
  /// Returns true if `alpha` has been explicitly set.
  var hasAlpha: Bool {return self._alpha != nil}
  /// Clears the value of `alpha`. Subsequent reads from it will return its default value.
  mutating func clearAlpha() {self._alpha = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _red: Float? = nil
  fileprivate var _green: Float? = nil
  fileprivate var _blue: Float? = nil
  fileprivate var _alpha: Float? = nil
}

/// Represents an attachment (embedded object)
struct AttachmentInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var attachmentIdentifier: String {
    get {return _attachmentIdentifier ?? String()}
    set {_attachmentIdentifier = newValue}
  }
  /// Returns true if `attachmentIdentifier` has been explicitly set.
  var hasAttachmentIdentifier: Bool {return self._attachmentIdentifier != nil}
  /// Clears the value of `attachmentIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearAttachmentIdentifier() {self._attachmentIdentifier = nil}

  var typeUti: String {
    get {return _typeUti ?? String()}
    set {_typeUti = newValue}
  }
  /// Returns true if `typeUti` has been explicitly set.
  var hasTypeUti: Bool {return self._typeUti != nil}
  /// Clears the value of `typeUti`. Subsequent reads from it will return its default value.
  mutating func clearTypeUti() {self._typeUti = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _attachmentIdentifier: String? = nil
  fileprivate var _typeUti: String? = nil
}

/// Represents a font
struct ProtoFont: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fontName: String {
    get {return _fontName ?? String()}
    set {_fontName = newValue}
  }
  /// Returns true if `fontName` has been explicitly set.
  var hasFontName: Bool {return self._fontName != nil}
  /// Clears the value of `fontName`. Subsequent reads from it will return its default value.
  mutating func clearFontName() {self._fontName = nil}

  var pointSize: Float {
    get {return _pointSize ?? 0}
    set {_pointSize = newValue}
  }
  /// Returns true if `pointSize` has been explicitly set.
  var hasPointSize: Bool {return self._pointSize != nil}
  /// Clears the value of `pointSize`. Subsequent reads from it will return its default value.
  mutating func clearPointSize() {self._pointSize = nil}

  var fontHints: Int32 {
    get {return _fontHints ?? 0}
    set {_fontHints = newValue}
  }
  /// Returns true if `fontHints` has been explicitly set.
  var hasFontHints: Bool {return self._fontHints != nil}
  /// Clears the value of `fontHints`. Subsequent reads from it will return its default value.
  mutating func clearFontHints() {self._fontHints = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fontName: String? = nil
  fileprivate var _pointSize: Float? = nil
  fileprivate var _fontHints: Int32? = nil
}

/// Styles a "Paragraph" (any run of characters in an AttributeRun)
struct ProtoParagraphStyle: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var styleType: Int32 {
    get {return _styleType ?? -1}
    set {_styleType = newValue}
  }
  /// Returns true if `styleType` has been explicitly set.
  var hasStyleType: Bool {return self._styleType != nil}
  /// Clears the value of `styleType`. Subsequent reads from it will return its default value.
  mutating func clearStyleType() {self._styleType = nil}

  var alignment: Int32 {
    get {return _alignment ?? 0}
    set {_alignment = newValue}
  }
  /// Returns true if `alignment` has been explicitly set.
  var hasAlignment: Bool {return self._alignment != nil}
  /// Clears the value of `alignment`. Subsequent reads from it will return its default value.
  mutating func clearAlignment() {self._alignment = nil}

  var indentAmount: Int32 {
    get {return _indentAmount ?? 0}
    set {_indentAmount = newValue}
  }
  /// Returns true if `indentAmount` has been explicitly set.
  var hasIndentAmount: Bool {return self._indentAmount != nil}
  /// Clears the value of `indentAmount`. Subsequent reads from it will return its default value.
  mutating func clearIndentAmount() {self._indentAmount = nil}

  var checklist: ProtoChecklist {
    get {return _checklist ?? ProtoChecklist()}
    set {_checklist = newValue}
  }
  /// Returns true if `checklist` has been explicitly set.
  var hasChecklist: Bool {return self._checklist != nil}
  /// Clears the value of `checklist`. Subsequent reads from it will return its default value.
  mutating func clearChecklist() {self._checklist = nil}

  var blockQuote: Int32 {
    get {return _blockQuote ?? 0}
    set {_blockQuote = newValue}
  }
  /// Returns true if `blockQuote` has been explicitly set.
  var hasBlockQuote: Bool {return self._blockQuote != nil}
  /// Clears the value of `blockQuote`. Subsequent reads from it will return its default value.
  mutating func clearBlockQuote() {self._blockQuote = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _styleType: Int32? = nil
  fileprivate var _alignment: Int32? = nil
  fileprivate var _indentAmount: Int32? = nil
  fileprivate var _checklist: ProtoChecklist? = nil
  fileprivate var _blockQuote: Int32? = nil
}

/// Represents a checklist item
struct ProtoChecklist: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: Data {
    get {return _uuid ?? Data()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {self._uuid = nil}

  var done: Int32 {
    get {return _done ?? 0}
    set {_done = newValue}
  }
  /// Returns true if `done` has been explicitly set.
  var hasDone: Bool {return self._done != nil}
  /// Clears the value of `done`. Subsequent reads from it will return its default value.
  mutating func clearDone() {self._done = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uuid: Data? = nil
  fileprivate var _done: Int32? = nil
}

/// Represents an object that has pointers to a key and a value, asserting
/// somehow that the key object has to do with the value object.
struct ProtoDictionaryElement: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: ObjectID {
    get {return _key ?? ObjectID()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var value: ObjectID {
    get {return _value ?? ObjectID()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: ObjectID? = nil
  fileprivate var _value: ObjectID? = nil
}

/// A Dictionary holds many ProtoDictionaryElements
struct ProtoDictionary: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var element: [ProtoDictionaryElement] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ObjectIDs are used to identify objects within the protobuf, offsets in an arry, or
/// a simple String.
struct ObjectID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unsignedIntegerValue: UInt64 {
    get {return _unsignedIntegerValue ?? 0}
    set {_unsignedIntegerValue = newValue}
  }
  /// Returns true if `unsignedIntegerValue` has been explicitly set.
  var hasUnsignedIntegerValue: Bool {return self._unsignedIntegerValue != nil}
  /// Clears the value of `unsignedIntegerValue`. Subsequent reads from it will return its default value.
  mutating func clearUnsignedIntegerValue() {self._unsignedIntegerValue = nil}

  var stringValue: String {
    get {return _stringValue ?? String()}
    set {_stringValue = newValue}
  }
  /// Returns true if `stringValue` has been explicitly set.
  var hasStringValue: Bool {return self._stringValue != nil}
  /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
  mutating func clearStringValue() {self._stringValue = nil}

  var objectIndex: Int32 {
    get {return _objectIndex ?? 0}
    set {_objectIndex = newValue}
  }
  /// Returns true if `objectIndex` has been explicitly set.
  var hasObjectIndex: Bool {return self._objectIndex != nil}
  /// Clears the value of `objectIndex`. Subsequent reads from it will return its default value.
  mutating func clearObjectIndex() {self._objectIndex = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _unsignedIntegerValue: UInt64? = nil
  fileprivate var _stringValue: String? = nil
  fileprivate var _objectIndex: Int32? = nil
}

/// Register Latest is used to identify the most recent version
struct RegisterLatest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contents: ObjectID {
    get {return _contents ?? ObjectID()}
    set {_contents = newValue}
  }
  /// Returns true if `contents` has been explicitly set.
  var hasContents: Bool {return self._contents != nil}
  /// Clears the value of `contents`. Subsequent reads from it will return its default value.
  mutating func clearContents() {self._contents = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contents: ObjectID? = nil
}

/// MapEntries have a key that maps to an array of key items and a value that points to an object.
struct MapEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: Int32 {
    get {return _key ?? 0}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var value: ObjectID {
    get {return _value ?? ObjectID()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  mutating func clearValue() {self._value = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _key: Int32? = nil
  fileprivate var _value: ObjectID? = nil
}

/// Represents a "run" of characters that need to be styled/displayed/etc
struct AttributeRun: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var length: Int32 {
    get {return _storage._length ?? 0}
    set {_uniqueStorage()._length = newValue}
  }
  /// Returns true if `length` has been explicitly set.
  var hasLength: Bool {return _storage._length != nil}
  /// Clears the value of `length`. Subsequent reads from it will return its default value.
  mutating func clearLength() {_uniqueStorage()._length = nil}

  var paragraphStyle: ProtoParagraphStyle {
    get {return _storage._paragraphStyle ?? ProtoParagraphStyle()}
    set {_uniqueStorage()._paragraphStyle = newValue}
  }
  /// Returns true if `paragraphStyle` has been explicitly set.
  var hasParagraphStyle: Bool {return _storage._paragraphStyle != nil}
  /// Clears the value of `paragraphStyle`. Subsequent reads from it will return its default value.
  mutating func clearParagraphStyle() {_uniqueStorage()._paragraphStyle = nil}

  var font: ProtoFont {
    get {return _storage._font ?? ProtoFont()}
    set {_uniqueStorage()._font = newValue}
  }
  /// Returns true if `font` has been explicitly set.
  var hasFont: Bool {return _storage._font != nil}
  /// Clears the value of `font`. Subsequent reads from it will return its default value.
  mutating func clearFont() {_uniqueStorage()._font = nil}

  var fontWeight: Int32 {
    get {return _storage._fontWeight ?? 0}
    set {_uniqueStorage()._fontWeight = newValue}
  }
  /// Returns true if `fontWeight` has been explicitly set.
  var hasFontWeight: Bool {return _storage._fontWeight != nil}
  /// Clears the value of `fontWeight`. Subsequent reads from it will return its default value.
  mutating func clearFontWeight() {_uniqueStorage()._fontWeight = nil}

  var underlined: Int32 {
    get {return _storage._underlined ?? 0}
    set {_uniqueStorage()._underlined = newValue}
  }
  /// Returns true if `underlined` has been explicitly set.
  var hasUnderlined: Bool {return _storage._underlined != nil}
  /// Clears the value of `underlined`. Subsequent reads from it will return its default value.
  mutating func clearUnderlined() {_uniqueStorage()._underlined = nil}

  var strikethrough: Int32 {
    get {return _storage._strikethrough ?? 0}
    set {_uniqueStorage()._strikethrough = newValue}
  }
  /// Returns true if `strikethrough` has been explicitly set.
  var hasStrikethrough: Bool {return _storage._strikethrough != nil}
  /// Clears the value of `strikethrough`. Subsequent reads from it will return its default value.
  mutating func clearStrikethrough() {_uniqueStorage()._strikethrough = nil}

  ///Sign indicates super/sub
  var superscript: Int32 {
    get {return _storage._superscript ?? 0}
    set {_uniqueStorage()._superscript = newValue}
  }
  /// Returns true if `superscript` has been explicitly set.
  var hasSuperscript: Bool {return _storage._superscript != nil}
  /// Clears the value of `superscript`. Subsequent reads from it will return its default value.
  mutating func clearSuperscript() {_uniqueStorage()._superscript = nil}

  var link: String {
    get {return _storage._link ?? String()}
    set {_uniqueStorage()._link = newValue}
  }
  /// Returns true if `link` has been explicitly set.
  var hasLink: Bool {return _storage._link != nil}
  /// Clears the value of `link`. Subsequent reads from it will return its default value.
  mutating func clearLink() {_uniqueStorage()._link = nil}

  var color: ProtoColor {
    get {return _storage._color ?? ProtoColor()}
    set {_uniqueStorage()._color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return _storage._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {_uniqueStorage()._color = nil}

  var attachmentInfo: AttachmentInfo {
    get {return _storage._attachmentInfo ?? AttachmentInfo()}
    set {_uniqueStorage()._attachmentInfo = newValue}
  }
  /// Returns true if `attachmentInfo` has been explicitly set.
  var hasAttachmentInfo: Bool {return _storage._attachmentInfo != nil}
  /// Clears the value of `attachmentInfo`. Subsequent reads from it will return its default value.
  mutating func clearAttachmentInfo() {_uniqueStorage()._attachmentInfo = nil}

  var unknownIdentifier: Int32 {
    get {return _storage._unknownIdentifier ?? 0}
    set {_uniqueStorage()._unknownIdentifier = newValue}
  }
  /// Returns true if `unknownIdentifier` has been explicitly set.
  var hasUnknownIdentifier: Bool {return _storage._unknownIdentifier != nil}
  /// Clears the value of `unknownIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearUnknownIdentifier() {_uniqueStorage()._unknownIdentifier = nil}

  var emphasisStyle: Int32 {
    get {return _storage._emphasisStyle ?? 0}
    set {_uniqueStorage()._emphasisStyle = newValue}
  }
  /// Returns true if `emphasisStyle` has been explicitly set.
  var hasEmphasisStyle: Bool {return _storage._emphasisStyle != nil}
  /// Clears the value of `emphasisStyle`. Subsequent reads from it will return its default value.
  mutating func clearEmphasisStyle() {_uniqueStorage()._emphasisStyle = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Overarching object in a ZNOTEDATA.ZDATA blob
struct NoteStoreProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var document: Document {
    get {return _document ?? Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  mutating func clearDocument() {self._document = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _document: Document? = nil
}

/// A Document has a Note within it.
struct Document: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: Int32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var note: Note {
    get {return _note ?? Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  mutating func clearNote() {self._note = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: Int32? = nil
  fileprivate var _note: Note? = nil
}

/// A Note has both text, and then a lot of formatting entries.
/// Other fields are present and not yet included in this proto.
struct Note: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var noteText: String {
    get {return _noteText ?? String()}
    set {_noteText = newValue}
  }
  /// Returns true if `noteText` has been explicitly set.
  var hasNoteText: Bool {return self._noteText != nil}
  /// Clears the value of `noteText`. Subsequent reads from it will return its default value.
  mutating func clearNoteText() {self._noteText = nil}

  var attributeRun: [AttributeRun] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _noteText: String? = nil
}

/// Represents the top level object in a ZMERGEABLEDATA cell
struct MergableDataProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mergableDataObject: MergableDataObject {
    get {return _mergableDataObject ?? MergableDataObject()}
    set {_mergableDataObject = newValue}
  }
  /// Returns true if `mergableDataObject` has been explicitly set.
  var hasMergableDataObject: Bool {return self._mergableDataObject != nil}
  /// Clears the value of `mergableDataObject`. Subsequent reads from it will return its default value.
  mutating func clearMergableDataObject() {self._mergableDataObject = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mergableDataObject: MergableDataObject? = nil
}

/// Similar to Document for Notes, this is what holds the mergeable object
struct MergableDataObject: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Asserted to be version in https://github.com/dunhamsteve/notesutils
  var version: Int32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var mergeableDataObjectData: MergeableDataObjectData {
    get {return _mergeableDataObjectData ?? MergeableDataObjectData()}
    set {_mergeableDataObjectData = newValue}
  }
  /// Returns true if `mergeableDataObjectData` has been explicitly set.
  var hasMergeableDataObjectData: Bool {return self._mergeableDataObjectData != nil}
  /// Clears the value of `mergeableDataObjectData`. Subsequent reads from it will return its default value.
  mutating func clearMergeableDataObjectData() {self._mergeableDataObjectData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: Int32? = nil
  fileprivate var _mergeableDataObjectData: MergeableDataObjectData? = nil
}

/// This is the mergeable data object itself and has a lot of entries that are the parts of it
/// along with arrays of key, type, and UUID items, depending on type.
struct MergeableDataObjectData: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mergeableDataObjectEntry: [MergeableDataObjectEntry] = []

  var mergeableDataObjectKeyItem: [String] = []

  var mergeableDataObjectTypeItem: [String] = []

  var mergeableDataObjectUuidItem: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Each entry is part of the pbject. For example, one entry might be identifying which
/// UUIDs are rows, and another might hold the text of a cell.
struct MergeableDataObjectEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var registerLatest: RegisterLatest {
    get {return _registerLatest ?? RegisterLatest()}
    set {_registerLatest = newValue}
  }
  /// Returns true if `registerLatest` has been explicitly set.
  var hasRegisterLatest: Bool {return self._registerLatest != nil}
  /// Clears the value of `registerLatest`. Subsequent reads from it will return its default value.
  mutating func clearRegisterLatest() {self._registerLatest = nil}

  var list: ProtoList {
    get {return _list ?? ProtoList()}
    set {_list = newValue}
  }
  /// Returns true if `list` has been explicitly set.
  var hasList: Bool {return self._list != nil}
  /// Clears the value of `list`. Subsequent reads from it will return its default value.
  mutating func clearList() {self._list = nil}

  var dictionary: ProtoDictionary {
    get {return _dictionary ?? ProtoDictionary()}
    set {_dictionary = newValue}
  }
  /// Returns true if `dictionary` has been explicitly set.
  var hasDictionary: Bool {return self._dictionary != nil}
  /// Clears the value of `dictionary`. Subsequent reads from it will return its default value.
  mutating func clearDictionary() {self._dictionary = nil}

  var unknownMessage: UnknownMergeableDataObjectEntryMessage {
    get {return _unknownMessage ?? UnknownMergeableDataObjectEntryMessage()}
    set {_unknownMessage = newValue}
  }
  /// Returns true if `unknownMessage` has been explicitly set.
  var hasUnknownMessage: Bool {return self._unknownMessage != nil}
  /// Clears the value of `unknownMessage`. Subsequent reads from it will return its default value.
  mutating func clearUnknownMessage() {self._unknownMessage = nil}

  var note: Note {
    get {return _note ?? Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  mutating func clearNote() {self._note = nil}

  var customMap: MergeableDataObjectMap {
    get {return _customMap ?? MergeableDataObjectMap()}
    set {_customMap = newValue}
  }
  /// Returns true if `customMap` has been explicitly set.
  var hasCustomMap: Bool {return self._customMap != nil}
  /// Clears the value of `customMap`. Subsequent reads from it will return its default value.
  mutating func clearCustomMap() {self._customMap = nil}

  var orderedSet: OrderedSet {
    get {return _orderedSet ?? OrderedSet()}
    set {_orderedSet = newValue}
  }
  /// Returns true if `orderedSet` has been explicitly set.
  var hasOrderedSet: Bool {return self._orderedSet != nil}
  /// Clears the value of `orderedSet`. Subsequent reads from it will return its default value.
  mutating func clearOrderedSet() {self._orderedSet = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _registerLatest: RegisterLatest? = nil
  fileprivate var _list: ProtoList? = nil
  fileprivate var _dictionary: ProtoDictionary? = nil
  fileprivate var _unknownMessage: UnknownMergeableDataObjectEntryMessage? = nil
  fileprivate var _note: Note? = nil
  fileprivate var _customMap: MergeableDataObjectMap? = nil
  fileprivate var _orderedSet: OrderedSet? = nil
}

/// This is unknown, it first was noticed in folder order analysis.
struct UnknownMergeableDataObjectEntryMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownEntry: UnknownMergeableDataObjectEntryMessageEntry {
    get {return _unknownEntry ?? UnknownMergeableDataObjectEntryMessageEntry()}
    set {_unknownEntry = newValue}
  }
  /// Returns true if `unknownEntry` has been explicitly set.
  var hasUnknownEntry: Bool {return self._unknownEntry != nil}
  /// Clears the value of `unknownEntry`. Subsequent reads from it will return its default value.
  mutating func clearUnknownEntry() {self._unknownEntry = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _unknownEntry: UnknownMergeableDataObjectEntryMessageEntry? = nil
}

/// This is unknown, it first was noticed in folder order analysis.
/// "unknown_int2" is where the folder order is stored
struct UnknownMergeableDataObjectEntryMessageEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownInt1: Int32 {
    get {return _unknownInt1 ?? 0}
    set {_unknownInt1 = newValue}
  }
  /// Returns true if `unknownInt1` has been explicitly set.
  var hasUnknownInt1: Bool {return self._unknownInt1 != nil}
  /// Clears the value of `unknownInt1`. Subsequent reads from it will return its default value.
  mutating func clearUnknownInt1() {self._unknownInt1 = nil}

  var unknownInt2: Int64 {
    get {return _unknownInt2 ?? 0}
    set {_unknownInt2 = newValue}
  }
  /// Returns true if `unknownInt2` has been explicitly set.
  var hasUnknownInt2: Bool {return self._unknownInt2 != nil}
  /// Clears the value of `unknownInt2`. Subsequent reads from it will return its default value.
  mutating func clearUnknownInt2() {self._unknownInt2 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _unknownInt1: Int32? = nil
  fileprivate var _unknownInt2: Int64? = nil
}

/// The Object Map uses its type to identify what you are looking at and
/// then a map entry to do something with that value.
struct MergeableDataObjectMap: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Int32 {
    get {return _type ?? 0}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var mapEntry: [MapEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: Int32? = nil
}

/// An ordered set is used to hold structural information for embedded tables
struct OrderedSet: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ordering: OrderedSetOrdering {
    get {return _ordering ?? OrderedSetOrdering()}
    set {_ordering = newValue}
  }
  /// Returns true if `ordering` has been explicitly set.
  var hasOrdering: Bool {return self._ordering != nil}
  /// Clears the value of `ordering`. Subsequent reads from it will return its default value.
  mutating func clearOrdering() {self._ordering = nil}

  var elements: ProtoDictionary {
    get {return _elements ?? ProtoDictionary()}
    set {_elements = newValue}
  }
  /// Returns true if `elements` has been explicitly set.
  var hasElements: Bool {return self._elements != nil}
  /// Clears the value of `elements`. Subsequent reads from it will return its default value.
  mutating func clearElements() {self._elements = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ordering: OrderedSetOrdering? = nil
  fileprivate var _elements: ProtoDictionary? = nil
}

/// The ordered set ordering identifies rows and columns in embedded tables, with an array
/// of the objects and contents that map lookup values to originals.
struct OrderedSetOrdering: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var array: OrderedSetOrderingArray {
    get {return _array ?? OrderedSetOrderingArray()}
    set {_array = newValue}
  }
  /// Returns true if `array` has been explicitly set.
  var hasArray: Bool {return self._array != nil}
  /// Clears the value of `array`. Subsequent reads from it will return its default value.
  mutating func clearArray() {self._array = nil}

  var contents: ProtoDictionary {
    get {return _contents ?? ProtoDictionary()}
    set {_contents = newValue}
  }
  /// Returns true if `contents` has been explicitly set.
  var hasContents: Bool {return self._contents != nil}
  /// Clears the value of `contents`. Subsequent reads from it will return its default value.
  mutating func clearContents() {self._contents = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _array: OrderedSetOrderingArray? = nil
  fileprivate var _contents: ProtoDictionary? = nil
}

/// This array holds both the text to replace and the array of UUIDs to tell what
/// embedded rows and columns are.
struct OrderedSetOrderingArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contents: Note {
    get {return _contents ?? Note()}
    set {_contents = newValue}
  }
  /// Returns true if `contents` has been explicitly set.
  var hasContents: Bool {return self._contents != nil}
  /// Clears the value of `contents`. Subsequent reads from it will return its default value.
  mutating func clearContents() {self._contents = nil}

  var attachment: [OrderedSetOrderingArrayAttachment] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _contents: Note? = nil
}

/// This array identifies the UUIDs that are embedded table rows or columns
struct OrderedSetOrderingArrayAttachment: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var index: Int32 {
    get {return _index ?? 0}
    set {_index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  var hasIndex: Bool {return self._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  mutating func clearIndex() {self._index = nil}

  var uuid: Data {
    get {return _uuid ?? Data()}
    set {_uuid = newValue}
  }
  /// Returns true if `uuid` has been explicitly set.
  var hasUuid: Bool {return self._uuid != nil}
  /// Clears the value of `uuid`. Subsequent reads from it will return its default value.
  mutating func clearUuid() {self._uuid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _index: Int32? = nil
  fileprivate var _uuid: Data? = nil
}

/// A ProtoList holds details about multiple objects
struct ProtoList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var listEntry: [ProtoListEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A list Entry holds details about a specific object
struct ProtoListEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: ObjectID {
    get {return _id ?? ObjectID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  /// I dislike this naming, but don't have better information
  var details: ProtoListEntryDetails {
    get {return _details ?? ProtoListEntryDetails()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  mutating func clearDetails() {self._details = nil}

  var additionalDetails: ProtoListEntryDetails {
    get {return _additionalDetails ?? ProtoListEntryDetails()}
    set {_additionalDetails = newValue}
  }
  /// Returns true if `additionalDetails` has been explicitly set.
  var hasAdditionalDetails: Bool {return self._additionalDetails != nil}
  /// Clears the value of `additionalDetails`. Subsequent reads from it will return its default value.
  mutating func clearAdditionalDetails() {self._additionalDetails = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: ObjectID? = nil
  fileprivate var _details: ProtoListEntryDetails? = nil
  fileprivate var _additionalDetails: ProtoListEntryDetails? = nil
}

/// ProtoList Entry Details hold another object ID and unidentified mapping
struct ProtoListEntryDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var listEntryDetailsKey: ProtoListEntryDetailsKey {
    get {return _listEntryDetailsKey ?? ProtoListEntryDetailsKey()}
    set {_listEntryDetailsKey = newValue}
  }
  /// Returns true if `listEntryDetailsKey` has been explicitly set.
  var hasListEntryDetailsKey: Bool {return self._listEntryDetailsKey != nil}
  /// Clears the value of `listEntryDetailsKey`. Subsequent reads from it will return its default value.
  mutating func clearListEntryDetailsKey() {self._listEntryDetailsKey = nil}

  var id: ObjectID {
    get {return _id ?? ObjectID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _listEntryDetailsKey: ProtoListEntryDetailsKey? = nil
  fileprivate var _id: ObjectID? = nil
}

struct ProtoListEntryDetailsKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var listEntryDetailsTypeIndex: Int32 {
    get {return _listEntryDetailsTypeIndex ?? 0}
    set {_listEntryDetailsTypeIndex = newValue}
  }
  /// Returns true if `listEntryDetailsTypeIndex` has been explicitly set.
  var hasListEntryDetailsTypeIndex: Bool {return self._listEntryDetailsTypeIndex != nil}
  /// Clears the value of `listEntryDetailsTypeIndex`. Subsequent reads from it will return its default value.
  mutating func clearListEntryDetailsTypeIndex() {self._listEntryDetailsTypeIndex = nil}

  var listEntryDetailsKey: Int32 {
    get {return _listEntryDetailsKey ?? 0}
    set {_listEntryDetailsKey = newValue}
  }
  /// Returns true if `listEntryDetailsKey` has been explicitly set.
  var hasListEntryDetailsKey: Bool {return self._listEntryDetailsKey != nil}
  /// Clears the value of `listEntryDetailsKey`. Subsequent reads from it will return its default value.
  mutating func clearListEntryDetailsKey() {self._listEntryDetailsKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _listEntryDetailsTypeIndex: Int32? = nil
  fileprivate var _listEntryDetailsKey: Int32? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ProtoColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoColor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "red"),
    2: .same(proto: "green"),
    3: .same(proto: "blue"),
    4: .same(proto: "alpha"),
  ]

  public var isInitialized: Bool {
    if self._red == nil {return false}
    if self._green == nil {return false}
    if self._blue == nil {return false}
    if self._alpha == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._red) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._green) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._blue) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._alpha) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._red {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._green {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._blue {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._alpha {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoColor, rhs: ProtoColor) -> Bool {
    if lhs._red != rhs._red {return false}
    if lhs._green != rhs._green {return false}
    if lhs._blue != rhs._blue {return false}
    if lhs._alpha != rhs._alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AttachmentInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AttachmentInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attachment_identifier"),
    2: .standard(proto: "type_uti"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._attachmentIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._typeUti) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._attachmentIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._typeUti {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AttachmentInfo, rhs: AttachmentInfo) -> Bool {
    if lhs._attachmentIdentifier != rhs._attachmentIdentifier {return false}
    if lhs._typeUti != rhs._typeUti {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoFont: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoFont"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "font_name"),
    2: .standard(proto: "point_size"),
    3: .standard(proto: "font_hints"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._fontName) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._pointSize) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._fontHints) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fontName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pointSize {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fontHints {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoFont, rhs: ProtoFont) -> Bool {
    if lhs._fontName != rhs._fontName {return false}
    if lhs._pointSize != rhs._pointSize {return false}
    if lhs._fontHints != rhs._fontHints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoParagraphStyle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoParagraphStyle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "style_type"),
    2: .same(proto: "alignment"),
    4: .standard(proto: "indent_amount"),
    5: .same(proto: "checklist"),
    8: .standard(proto: "block_quote"),
  ]

  public var isInitialized: Bool {
    if let v = self._checklist, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._styleType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._alignment) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._indentAmount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._checklist) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self._blockQuote) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._styleType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._alignment {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._indentAmount {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._checklist {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._blockQuote {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoParagraphStyle, rhs: ProtoParagraphStyle) -> Bool {
    if lhs._styleType != rhs._styleType {return false}
    if lhs._alignment != rhs._alignment {return false}
    if lhs._indentAmount != rhs._indentAmount {return false}
    if lhs._checklist != rhs._checklist {return false}
    if lhs._blockQuote != rhs._blockQuote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoChecklist: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoChecklist"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "done"),
  ]

  public var isInitialized: Bool {
    if self._uuid == nil {return false}
    if self._done == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._uuid) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._done) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uuid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._done {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoChecklist, rhs: ProtoChecklist) -> Bool {
    if lhs._uuid != rhs._uuid {return false}
    if lhs._done != rhs._done {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoDictionaryElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoDictionaryElement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    if let v = self._key, !v.isInitialized {return false}
    if let v = self._value, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoDictionaryElement, rhs: ProtoDictionaryElement) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoDictionary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoDictionary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "element"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.element) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.element) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.element.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.element, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoDictionary, rhs: ProtoDictionary) -> Bool {
    if lhs.element != rhs.element {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ObjectID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ObjectID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "unsigned_integer_value"),
    4: .standard(proto: "string_value"),
    6: .standard(proto: "object_index"),
  ]

  public var isInitialized: Bool {
    if self._unsignedIntegerValue == nil {return false}
    if self._stringValue == nil {return false}
    if self._objectIndex == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._unsignedIntegerValue) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._stringValue) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self._objectIndex) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._unsignedIntegerValue {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stringValue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._objectIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ObjectID, rhs: ObjectID) -> Bool {
    if lhs._unsignedIntegerValue != rhs._unsignedIntegerValue {return false}
    if lhs._stringValue != rhs._stringValue {return false}
    if lhs._objectIndex != rhs._objectIndex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RegisterLatest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RegisterLatest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "contents"),
  ]

  public var isInitialized: Bool {
    if self._contents == nil {return false}
    if let v = self._contents, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._contents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RegisterLatest, rhs: RegisterLatest) -> Bool {
    if lhs._contents != rhs._contents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MapEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MapEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    if let v = self._value, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MapEntry, rhs: MapEntry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AttributeRun: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AttributeRun"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "length"),
    2: .standard(proto: "paragraph_style"),
    3: .same(proto: "font"),
    5: .standard(proto: "font_weight"),
    6: .same(proto: "underlined"),
    7: .same(proto: "strikethrough"),
    8: .same(proto: "superscript"),
    9: .same(proto: "link"),
    10: .same(proto: "color"),
    12: .standard(proto: "attachment_info"),
    13: .standard(proto: "unknown_identifier"),
    14: .standard(proto: "emphasis_style"),
  ]

  fileprivate class _StorageClass {
    var _length: Int32? = nil
    var _paragraphStyle: ProtoParagraphStyle? = nil
    var _font: ProtoFont? = nil
    var _fontWeight: Int32? = nil
    var _underlined: Int32? = nil
    var _strikethrough: Int32? = nil
    var _superscript: Int32? = nil
    var _link: String? = nil
    var _color: ProtoColor? = nil
    var _attachmentInfo: AttachmentInfo? = nil
    var _unknownIdentifier: Int32? = nil
    var _emphasisStyle: Int32? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _length = source._length
      _paragraphStyle = source._paragraphStyle
      _font = source._font
      _fontWeight = source._fontWeight
      _underlined = source._underlined
      _strikethrough = source._strikethrough
      _superscript = source._superscript
      _link = source._link
      _color = source._color
      _attachmentInfo = source._attachmentInfo
      _unknownIdentifier = source._unknownIdentifier
      _emphasisStyle = source._emphasisStyle
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._length == nil {return false}
      if let v = _storage._paragraphStyle, !v.isInitialized {return false}
      if let v = _storage._color, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._length) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._paragraphStyle) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._font) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._fontWeight) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._underlined) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._strikethrough) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._superscript) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._link) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._color) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._attachmentInfo) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._unknownIdentifier) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._emphasisStyle) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._length {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._paragraphStyle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._font {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._fontWeight {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._underlined {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._strikethrough {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._superscript {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._link {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._color {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._attachmentInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._unknownIdentifier {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._emphasisStyle {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AttributeRun, rhs: AttributeRun) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._length != rhs_storage._length {return false}
        if _storage._paragraphStyle != rhs_storage._paragraphStyle {return false}
        if _storage._font != rhs_storage._font {return false}
        if _storage._fontWeight != rhs_storage._fontWeight {return false}
        if _storage._underlined != rhs_storage._underlined {return false}
        if _storage._strikethrough != rhs_storage._strikethrough {return false}
        if _storage._superscript != rhs_storage._superscript {return false}
        if _storage._link != rhs_storage._link {return false}
        if _storage._color != rhs_storage._color {return false}
        if _storage._attachmentInfo != rhs_storage._attachmentInfo {return false}
        if _storage._unknownIdentifier != rhs_storage._unknownIdentifier {return false}
        if _storage._emphasisStyle != rhs_storage._emphasisStyle {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NoteStoreProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NoteStoreProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "document"),
  ]

  public var isInitialized: Bool {
    if self._document == nil {return false}
    if let v = self._document, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NoteStoreProto, rhs: NoteStoreProto) -> Bool {
    if lhs._document != rhs._document {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Document: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Document"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "version"),
    3: .same(proto: "note"),
  ]

  public var isInitialized: Bool {
    if self._version == nil {return false}
    if self._note == nil {return false}
    if let v = self._note, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Document, rhs: Document) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._note != rhs._note {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Note: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Note"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "note_text"),
    5: .standard(proto: "attribute_run"),
  ]

  public var isInitialized: Bool {
    if self._noteText == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.attributeRun) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._noteText) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.attributeRun) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._noteText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.attributeRun.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributeRun, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Note, rhs: Note) -> Bool {
    if lhs._noteText != rhs._noteText {return false}
    if lhs.attributeRun != rhs.attributeRun {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MergableDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MergableDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "mergable_data_object"),
  ]

  public var isInitialized: Bool {
    if self._mergableDataObject == nil {return false}
    if let v = self._mergableDataObject, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mergableDataObject) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mergableDataObject {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MergableDataProto, rhs: MergableDataProto) -> Bool {
    if lhs._mergableDataObject != rhs._mergableDataObject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MergableDataObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MergableDataObject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "version"),
    3: .standard(proto: "mergeable_data_object_data"),
  ]

  public var isInitialized: Bool {
    if self._version == nil {return false}
    if self._mergeableDataObjectData == nil {return false}
    if let v = self._mergeableDataObjectData, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mergeableDataObjectData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mergeableDataObjectData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MergableDataObject, rhs: MergableDataObject) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._mergeableDataObjectData != rhs._mergeableDataObjectData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MergeableDataObjectData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MergeableDataObjectData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "mergeable_data_object_entry"),
    4: .standard(proto: "mergeable_data_object_key_item"),
    5: .standard(proto: "mergeable_data_object_type_item"),
    6: .standard(proto: "mergeable_data_object_uuid_item"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.mergeableDataObjectEntry) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mergeableDataObjectEntry) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.mergeableDataObjectKeyItem) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.mergeableDataObjectTypeItem) }()
      case 6: try { try decoder.decodeRepeatedBytesField(value: &self.mergeableDataObjectUuidItem) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mergeableDataObjectEntry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mergeableDataObjectEntry, fieldNumber: 3)
    }
    if !self.mergeableDataObjectKeyItem.isEmpty {
      try visitor.visitRepeatedStringField(value: self.mergeableDataObjectKeyItem, fieldNumber: 4)
    }
    if !self.mergeableDataObjectTypeItem.isEmpty {
      try visitor.visitRepeatedStringField(value: self.mergeableDataObjectTypeItem, fieldNumber: 5)
    }
    if !self.mergeableDataObjectUuidItem.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.mergeableDataObjectUuidItem, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MergeableDataObjectData, rhs: MergeableDataObjectData) -> Bool {
    if lhs.mergeableDataObjectEntry != rhs.mergeableDataObjectEntry {return false}
    if lhs.mergeableDataObjectKeyItem != rhs.mergeableDataObjectKeyItem {return false}
    if lhs.mergeableDataObjectTypeItem != rhs.mergeableDataObjectTypeItem {return false}
    if lhs.mergeableDataObjectUuidItem != rhs.mergeableDataObjectUuidItem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MergeableDataObjectEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MergeableDataObjectEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "register_latest"),
    5: .same(proto: "list"),
    6: .same(proto: "dictionary"),
    9: .standard(proto: "unknown_message"),
    10: .same(proto: "note"),
    13: .standard(proto: "custom_map"),
    16: .standard(proto: "ordered_set"),
  ]

  public var isInitialized: Bool {
    if self._registerLatest == nil {return false}
    if let v = self._registerLatest, !v.isInitialized {return false}
    if let v = self._list, !v.isInitialized {return false}
    if let v = self._dictionary, !v.isInitialized {return false}
    if let v = self._note, !v.isInitialized {return false}
    if let v = self._customMap, !v.isInitialized {return false}
    if let v = self._orderedSet, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._registerLatest) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._list) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._dictionary) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._unknownMessage) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._customMap) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &self._orderedSet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._registerLatest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._list {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._dictionary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._unknownMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._customMap {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._orderedSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MergeableDataObjectEntry, rhs: MergeableDataObjectEntry) -> Bool {
    if lhs._registerLatest != rhs._registerLatest {return false}
    if lhs._list != rhs._list {return false}
    if lhs._dictionary != rhs._dictionary {return false}
    if lhs._unknownMessage != rhs._unknownMessage {return false}
    if lhs._note != rhs._note {return false}
    if lhs._customMap != rhs._customMap {return false}
    if lhs._orderedSet != rhs._orderedSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UnknownMergeableDataObjectEntryMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UnknownMergeableDataObjectEntryMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unknown_entry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._unknownEntry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._unknownEntry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UnknownMergeableDataObjectEntryMessage, rhs: UnknownMergeableDataObjectEntryMessage) -> Bool {
    if lhs._unknownEntry != rhs._unknownEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UnknownMergeableDataObjectEntryMessageEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UnknownMergeableDataObjectEntryMessageEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unknown_int1"),
    2: .standard(proto: "unknown_int2"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._unknownInt1) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._unknownInt2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._unknownInt1 {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._unknownInt2 {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UnknownMergeableDataObjectEntryMessageEntry, rhs: UnknownMergeableDataObjectEntryMessageEntry) -> Bool {
    if lhs._unknownInt1 != rhs._unknownInt1 {return false}
    if lhs._unknownInt2 != rhs._unknownInt2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MergeableDataObjectMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MergeableDataObjectMap"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    3: .standard(proto: "map_entry"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.mapEntry) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._type) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mapEntry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.mapEntry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mapEntry, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MergeableDataObjectMap, rhs: MergeableDataObjectMap) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.mapEntry != rhs.mapEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderedSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "OrderedSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ordering"),
    2: .same(proto: "elements"),
  ]

  public var isInitialized: Bool {
    if self._ordering == nil {return false}
    if self._elements == nil {return false}
    if let v = self._ordering, !v.isInitialized {return false}
    if let v = self._elements, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._ordering) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._elements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ordering {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._elements {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OrderedSet, rhs: OrderedSet) -> Bool {
    if lhs._ordering != rhs._ordering {return false}
    if lhs._elements != rhs._elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderedSetOrdering: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "OrderedSetOrdering"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "array"),
    2: .same(proto: "contents"),
  ]

  public var isInitialized: Bool {
    if self._array == nil {return false}
    if self._contents == nil {return false}
    if let v = self._array, !v.isInitialized {return false}
    if let v = self._contents, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._array) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._contents) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._array {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._contents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OrderedSetOrdering, rhs: OrderedSetOrdering) -> Bool {
    if lhs._array != rhs._array {return false}
    if lhs._contents != rhs._contents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderedSetOrderingArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "OrderedSetOrderingArray"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contents"),
    2: .same(proto: "attachment"),
  ]

  public var isInitialized: Bool {
    if self._contents == nil {return false}
    if let v = self._contents, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.attachment) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._contents) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.attachment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contents {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.attachment.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachment, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OrderedSetOrderingArray, rhs: OrderedSetOrderingArray) -> Bool {
    if lhs._contents != rhs._contents {return false}
    if lhs.attachment != rhs.attachment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OrderedSetOrderingArrayAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "OrderedSetOrderingArrayAttachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "uuid"),
  ]

  public var isInitialized: Bool {
    if self._index == nil {return false}
    if self._uuid == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._index) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._index {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._uuid {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OrderedSetOrderingArrayAttachment, rhs: OrderedSetOrderingArrayAttachment) -> Bool {
    if lhs._index != rhs._index {return false}
    if lhs._uuid != rhs._uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_entry"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.listEntry) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.listEntry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listEntry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listEntry, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoList, rhs: ProtoList) -> Bool {
    if lhs.listEntry != rhs.listEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoListEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoListEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "id"),
    3: .same(proto: "details"),
    4: .standard(proto: "additional_details"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._additionalDetails == nil {return false}
    if let v = self._id, !v.isInitialized {return false}
    if let v = self._details, !v.isInitialized {return false}
    if let v = self._additionalDetails, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._additionalDetails) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._additionalDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoListEntry, rhs: ProtoListEntry) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._details != rhs._details {return false}
    if lhs._additionalDetails != rhs._additionalDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoListEntryDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoListEntryDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_entry_details_key"),
    2: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if let v = self._listEntryDetailsKey, !v.isInitialized {return false}
    if let v = self._id, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._listEntryDetailsKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._listEntryDetailsKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoListEntryDetails, rhs: ProtoListEntryDetails) -> Bool {
    if lhs._listEntryDetailsKey != rhs._listEntryDetailsKey {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoListEntryDetailsKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoListEntryDetailsKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_entry_details_type_index"),
    2: .standard(proto: "list_entry_details_key"),
  ]

  public var isInitialized: Bool {
    if self._listEntryDetailsTypeIndex == nil {return false}
    if self._listEntryDetailsKey == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._listEntryDetailsTypeIndex) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._listEntryDetailsKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._listEntryDetailsTypeIndex {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._listEntryDetailsKey {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoListEntryDetailsKey, rhs: ProtoListEntryDetailsKey) -> Bool {
    if lhs._listEntryDetailsTypeIndex != rhs._listEntryDetailsTypeIndex {return false}
    if lhs._listEntryDetailsKey != rhs._listEntryDetailsKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
